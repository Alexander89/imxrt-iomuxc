use imxrt_iomuxc_build::{write_pads, PadRange};

#[test]
fn test_write_pads() {
    let expected_tokens = quote::quote! {
        /// Contains all of the pads
        ///
        /// This module is auto-generated by the `imxrt-iomuxc-build` crate. See
        /// that crate for more information.
        mod pads {
            #![allow(non_camel_case_types)] // Conform with reference manual

            #[doc = "Pads with the prefix 'FOO'"]
            pub mod foo {
                use crate::{Pad, bases::*};
                use imxrt_iomuxc::consts::*;

                pub type FOO_02 = Pad<FOO, U2>;
                pub type FOO_03 = Pad<FOO, U3>;

                #[doc = "Pads with the prefix 'FOO'"]
                pub struct Pads {
                    pub p02: FOO_02,
                    pub p03: FOO_03
                }

                impl Pads {
                    /// Take all pads from this group
                    ///
                    /// # Safety
                    ///
                    /// You may safely call this once to acquire all of the pads. Subsequent calls
                    /// may return pads that are mutably aliased elsewhere. Consider calling `new()`
                    /// at the start of your program.
                    ///
                    /// Know that the top-level [`Pads::new()`](../struct.Pads.html#method.new) will call this `new()`.
                    pub const unsafe fn new() -> Pads {
                        Pads {
                            p02: <FOO_02>::new(),
                            p03: <FOO_03>::new()
                        }
                    }
                }
            }

            #[doc = "Pads with the prefix 'BAR'"]
            pub mod bar {
                use crate::{Pad, bases::*};
                use imxrt_iomuxc::consts::*;

                pub type BAR_37 = Pad<BAR, U37>;
                pub type BAR_38 = Pad<BAR, U38>;

                #[doc = "Pads with the prefix 'BAR'"]
                pub struct Pads {
                    pub p37: BAR_37,
                    pub p38: BAR_38
                }

                impl Pads {
                    /// Take all pads from this group
                    ///
                    /// # Safety
                    ///
                    /// You may safely call this once to acquire all of the pads. Subsequent calls
                    /// may return pads that are mutably aliased elsewhere. Consider calling `new()`
                    /// at the start of your program.
                    ///
                    /// Know that the top-level [`Pads::new()`](../struct.Pads.html#method.new) will call this `new()`.
                    pub const unsafe fn new() -> Pads {
                        Pads {
                            p37: <BAR_37>::new(),
                            p38: <BAR_38>::new()
                        }
                    }
                }
            }

            /// All of the pads
            ///
            /// # Convention
            ///
            /// The members of `Pads` are additional structs that provide pads as
            /// objects. The `p` prefix of each pad denotes "pad."
            pub struct Pads {
                pub foo: foo::Pads,
                pub bar: bar::Pads
            }

            impl Pads {
                /// Take all of the pads
                ///
                /// # Safety
                ///
                /// You may safely call this once to acquire all of the pads. Subsequent calls
                /// may return pads that are mutably aliased elsewhere. Consider calling `new()`
                /// at the start of your program.
                pub const unsafe fn new() -> Pads {
                    Pads {
                        foo: <foo::Pads>::new(),
                        bar: <bar::Pads>::new()
                    }
                }
            }
        }
    };
    let expected = expected_tokens.to_string();
    let mut actual = Vec::new();
    write_pads(
        &mut actual,
        vec![&PadRange::new("FOO", 2..4), &PadRange::new("BAR", 37..39)],
    )
    .unwrap();
    assert_eq!(std::str::from_utf8(&actual).unwrap(), expected);
}
